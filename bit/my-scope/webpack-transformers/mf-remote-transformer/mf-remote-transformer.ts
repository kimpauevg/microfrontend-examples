import type {
  WebpackConfigMutator,
  WebpackConfigTransformContext,
} from '@teambit/webpack';
import { container } from 'webpack';

const { ModuleFederationPlugin } = container;

const DEV_PUBLIC_PATH = 'http://localhost:60000/';
const PROD_PUBLIC_PATH = DEV_PUBLIC_PATH;

/* get a webpack config and return a mutated one */
export const moduleFederationRemoteTransformer = (
  configMutator: WebpackConfigMutator,
  _context: WebpackConfigTransformContext,
  appEntry: string
): WebpackConfigMutator => {
  configMutator.addPlugin(
    /* add the module federation plugin to the webpack bundle */
    new ModuleFederationPlugin({
      /**
       * the following is the path used by the host app, to load this app:
       * mars_weather@https://mf-remote.netlify.app/remoteEntry.js
       */
      name: 'mars_weather',
      /* this file is generated by the mf webpack plugin */
      filename: 'remoteEntry.js',
      exposes: {
        './AboutComponent': appEntry,
      },
      /**
       * a list of peer dependencies (to be loaded by the host app).
       */  
      shared: {
        react: {
          singleton: true,
          requiredVersion: '^18.2.0',
          eager: true,
        },
        'react-dom': {
          singleton: true,
          requiredVersion: '^18.2.0',
          eager: true,
        },
        'react-dom/client': {
          singleton: true,
          requiredVersion: '^18.2.0',
          eager: true,
        },
      },
    })
  );

  const mode = configMutator.raw.mode || 'development';

  configMutator.raw.output = configMutator.raw.output || {};
  configMutator.raw.output.publicPath = mode === 'development' ? DEV_PUBLIC_PATH : PROD_PUBLIC_PATH;

  return configMutator;
};
